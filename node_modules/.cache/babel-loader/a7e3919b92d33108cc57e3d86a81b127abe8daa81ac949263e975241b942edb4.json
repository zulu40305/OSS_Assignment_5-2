{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n  while (i < str.length) {\n    var char = str[i];\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({\n        type: \"MODIFIER\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \"\\\\\") {\n      tokens.push({\n        type: \"ESCAPED_CHAR\",\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \"{\") {\n      tokens.push({\n        type: \"OPEN\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \"}\") {\n      tokens.push({\n        type: \"CLOSE\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === \":\") {\n      var name = \"\";\n      var j = i + 1;\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n        if (\n        // `0-9`\n        code >= 48 && code <= 57 ||\n        // `A-Z`\n        code >= 65 && code <= 90 ||\n        // `a-z`\n        code >= 97 && code <= 122 ||\n        // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n        break;\n      }\n      if (!name) throw new TypeError(\"Missing parameter name at \" + i);\n      tokens.push({\n        type: \"NAME\",\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n    if (char === \"(\") {\n      var count = 1;\n      var pattern = \"\";\n      var j = i + 1;\n      if (str[j] === \"?\") {\n        throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n      }\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(\"Capturing groups are not allowed at \" + j);\n          }\n        }\n        pattern += str[j++];\n      }\n      if (count) throw new TypeError(\"Unbalanced pattern at \" + i);\n      if (!pattern) throw new TypeError(\"Missing pattern at \" + i);\n      tokens.push({\n        type: \"PATTERN\",\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n    tokens.push({\n      type: \"CHAR\",\n      index: i,\n      value: str[i++]\n    });\n  }\n  tokens.push({\n    type: \"END\",\n    index: i,\n    value: \"\"\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n    prefixes = _a === void 0 ? \"./\" : _a;\n  var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = \"\";\n  var tryConsume = function (type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n  var mustConsume = function (type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n      nextType = _a.type,\n      index = _a.index;\n    throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n  };\n  var consumeText = function () {\n    var result = \"\";\n    var value;\n    // tslint:disable-next-line\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result += value;\n    }\n    return result;\n  };\n  while (i < tokens.length) {\n    var char = tryConsume(\"CHAR\");\n    var name = tryConsume(\"NAME\");\n    var pattern = tryConsume(\"PATTERN\");\n    if (name || pattern) {\n      var prefix = char || \"\";\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n    var value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n    var open = tryConsume(\"OPEN\");\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume(\"NAME\") || \"\";\n      var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n      var suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : \"\"),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n    mustConsume(\"END\");\n  }\n  return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var reFlags = flags(options);\n  var _a = options.encode,\n    encode = _a === void 0 ? function (x) {\n      return x;\n    } : _a,\n    _b = options.validate,\n    validate = _b === void 0 ? true : _b;\n  // Compile all the tokens into regexps.\n  var matches = tokens.map(function (token) {\n    if (typeof token === \"object\") {\n      return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n    }\n  });\n  return function (data) {\n    var path = \"\";\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === \"?\" || token.modifier === \"*\";\n      var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n        }\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n        }\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n          }\n          path += token.prefix + segment + token.suffix;\n        }\n        continue;\n      }\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        var segment = encode(String(value), token);\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n        }\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n      if (optional) continue;\n      var typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n    }\n    return path;\n  };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.decode,\n    decode = _a === void 0 ? function (x) {\n      return x;\n    } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n      index = m.index;\n    var params = Object.create(null);\n    var _loop_1 = function (i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return \"continue\";\n      var key = keys[i - 1];\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path;\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: \"\",\n        suffix: \"\",\n        modifier: \"\",\n        pattern: \"\"\n      });\n    }\n  }\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.strict,\n    strict = _a === void 0 ? false : _a,\n    _b = options.start,\n    start = _b === void 0 ? true : _b,\n    _c = options.end,\n    end = _c === void 0 ? true : _c,\n    _d = options.encode,\n    encode = _d === void 0 ? function (x) {\n      return x;\n    } : _d;\n  var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n  var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n  var route = start ? \"^\" : \"\";\n  // Iterate over the tokens and create our regexp string.\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n      if (token.pattern) {\n        if (keys) keys.push(token);\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            var mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n          } else {\n            route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n          }\n        } else {\n          route += \"(\" + token.pattern + \")\" + token.modifier;\n        }\n      } else {\n        route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n      }\n    }\n  }\n  if (end) {\n    if (!strict) route += delimiter + \"?\";\n    route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 :\n    // tslint:disable-next-line\n    endToken === undefined;\n    if (!strict) {\n      route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n    }\n    if (!isEndDelimited) {\n      route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n    }\n  }\n  return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;","map":{"version":3,"names":["Object","defineProperty","exports","value","lexer","str","tokens","i","length","char","push","type","index","name","j","code","charCodeAt","TypeError","count","pattern","parse","options","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","open","name_1","pattern_1","compile","tokensToFunction","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","String","typeOfMessage","match","keys","re","pathToRegexp","regexpToFunction","decode","pathname","m","exec","params","create","_loop_1","split","replace","sensitive","regexpToRegexp","groups","source","arrayToRegexp","paths","parts","join","stringToRegexp","tokensToRegexp","strict","start","_c","end","_d","endsWith","route","_i","tokens_1","mod","endToken","isEndDelimited"],"sources":["/Users/zuru/node_modules/next/dist/compiled/path-to-regexp/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}